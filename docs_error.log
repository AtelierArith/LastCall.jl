Precompiling packages...
   1944.7 ms  ✓ LastCall
  1 dependency successfully precompiled in 2 seconds. 42 already precompiled.
[ Info: SetupBuildDirectory: setting up build directory.
[ Info: Doctest: running doctests.
[ Info: ExpandTemplates: expanding markdown templates.
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:22-55
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct Point2D {
│     x: f64,
│     y: f64,
│ }
│ 
│ impl Point2D {
│     pub fn new(x: f64, y: f64) -> Self {
│         Point2D { x, y }
│     }
│     
│     pub fn distance(&self) -> f64 {
│         (self.x * self.x + self.y * self.y).sqrt()
│     }
│ }
│ """
│ 
│ # Create a Point2D instance
│ p = Point2D(3.0, 4.0)
│ 
│ # Access fields directly
│ println(p.x)  # => 3.0
│ println(p.y)  # => 4.0
│ 
│ # Modify fields
│ p.y = 5.0
│ println(p.y)  # => 5.0
│ 
│ # Call methods
│ dist = p.distance()
│ println(dist)  # => 5.830951894845301
│ ```
│   exception =
│    syntax: "LastCall.##args#313" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:23
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:59-88
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct, Clone)]
│ pub struct PersonInfo {
│     name: String,
│     age: i32,
│ }
│ 
│ impl PersonInfo {
│     pub fn new(name: String, age: i32) -> Self {
│         PersonInfo { name, age }
│     }
│     
│     pub fn get_name(&self) -> String {
│         self.name.clone()
│     }
│ }
│ """
│ 
│ # Create a person
│ person = PersonInfo("Alice", 30)
│ 
│ # Clone the person
│ person2 = copy(person)  # Uses Rust's Clone trait
│ 
│ # Both are independent objects
│ person.age = 31
│ println(person.age)   # => 31
│ println(person2.age)  # => 30
│ ```
│   exception =
│    syntax: "LastCall.##args#315" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:60
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:107-125
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct, Clone)]
│ pub struct Config {
│     host: String,
│     port: i32,
│     timeout: f64,
│ }
│ 
│ impl Config {
│     pub fn new(host: String, port: i32, timeout: f64) -> Self {
│         Config { host, port, timeout }
│     }
│ }
│ """
│ 
│ config = Config("localhost", 8080, 30.0)
│ config2 = copy(config)  # Clone support
│ ```
│   exception =
│    syntax: "LastCall.##args#317" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:108
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:136-167
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct Rectangle {
│     width: f64,
│     height: f64,
│ }
│ 
│ impl Rectangle {
│     pub fn new(width: f64, height: f64) -> Self {
│         Rectangle { width, height }
│     }
│     
│     pub fn area(&self) -> f64 {
│         self.width * self.height
│     }
│ }
│ """
│ 
│ rect = Rectangle(10.0, 20.0)
│ 
│ # Get field values
│ w = rect.width   # => 10.0
│ h = rect.height  # => 20.0
│ 
│ # Set field values
│ rect.width = 15.0
│ rect.height = 25.0
│ 
│ # Calculate area
│ area = rect.area()  # => 375.0
│ ```
│   exception =
│    syntax: "LastCall.##args#318" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:137
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:187-211
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct Pair<T> {
│     first: T,
│     second: T,
│ }
│ 
│ impl<T> Pair<T> {
│     pub fn new(first: T, second: T) -> Self {
│         Pair { first, second }
│     }
│ }
│ """
│ 
│ # Create a Pair with Int32
│ pair_int = Pair{Int32}(10, 20)
│ println(pair_int.first)   # => 10
│ println(pair_int.second)  # => 20
│ 
│ # Create a Pair with Float64
│ pair_float = Pair{Float64}(3.14, 2.71)
│ println(pair_float.first)   # => 3.14
│ println(pair_float.second)  # => 2.71
│ ```
│   exception =
│    FieldError: type Main.__atexample__named__struct_mapping.Pair has no field `first`, available fields: `ptr`, `lib_name`
│    Stacktrace:
│      [1] getproperty(x::Main.__atexample__named__struct_mapping.Pair{Int32}, f::Symbol)
│        @ Base ./Base_compiler.jl:54
│      [2] top-level scope
│        @ struct_mapping.md:204
│      [3] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [4] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [5] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [6] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [7] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [8] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [9] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│     [10] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [11] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:221-250
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct Resource {
│     id: i32,
│     data: Vec<u8>,
│ }
│ 
│ impl Resource {
│     pub fn new(id: i32, data: Vec<u8>) -> Self {
│         Resource { id, data }
│     }
│ }
│ 
│ impl Drop for Resource {
│     fn drop(&mut self) {
│         println!("Dropping resource {}", self.id);
│     }
│ }
│ """
│ 
│ # Resource is automatically cleaned up when it goes out of scope
│ function use_resource()
│     res = Resource(1, [1, 2, 3])
│     # ... use resource ...
│     # Drop is automatically called when res goes out of scope
│ end
│ 
│ use_resource()  # Prints: "Dropping resource 1"
│ ```
│   exception =
│    syntax: "LastCall.##args#320" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:222
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:256-292
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct Calculator {
│     value: f64,
│ }
│ 
│ impl Calculator {
│     pub fn new(value: f64) -> Self {
│         Calculator { value }
│     }
│     
│     pub fn add(&mut self, x: f64) {
│         self.value += x;
│     }
│     
│     pub fn multiply(&mut self, x: f64) {
│         self.value *= x;
│     }
│     
│     pub fn get_value(&self) -> f64 {
│         self.value
│     }
│     
│     pub fn reset(&mut self) {
│         self.value = 0.0;
│     }
│ }
│ """
│ 
│ calc = Calculator(10.0)
│ calc.add(5.0)
│ calc.multiply(2.0)
│ println(calc.get_value())  # => 30.0
│ calc.reset()
│ println(calc.get_value())  # => 0.0
│ ```
│   exception =
│    syntax: "LastCall.##args#321" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:257
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:298-317
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct)]
│ pub struct MathUtils;
│ 
│ impl MathUtils {
│     pub fn add(a: f64, b: f64) -> f64 {
│         a + b
│     }
│     
│     pub fn multiply(a: f64, b: f64) -> f64 {
│         a * b
│     }
│ }
│ """
│ 
│ # Call static methods
│ result1 = MathUtils.add(3.0, 4.0)      # => 7.0
│ result2 = MathUtils.multiply(3.0, 4.0) # => 12.0
│ ```
│   exception =
│    UndefVarError: `MathUtils` not defined in `Main.__atexample__named__struct_mapping`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:315
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/struct_mapping.md:414-480
│ ```@example struct_mapping
│ rust"""
│ #[derive(JuliaStruct, Clone)]
│ pub struct Vec2DD {
│     x: f64,
│     y: f64,
│ }
│ 
│ impl Vec2DD {
│     pub fn new(x: f64, y: f64) -> Self {
│         Vec2DD { x, y }
│     }
│     
│     pub fn zero() -> Self {
│         Vec2DD { x: 0.0, y: 0.0 }
│     }
│     
│     pub fn add(&self, other: &Vec2DD) -> Vec2DD {
│         Vec2DD {
│             x: self.x + other.x,
│             y: self.y + other.y,
│         }
│     }
│     
│     pub fn scale(&mut self, factor: f64) {
│         self.x *= factor;
│         self.y *= factor;
│     }
│     
│     pub fn magnitude(&self) -> f64 {
│         (self.x * self.x + self.y * self.y).sqrt()
│     }
│     
│     pub fn normalize(&mut self) {
│         let mag = self.magnitude();
│         if mag > 0.0 {
│             self.scale(1.0 / mag);
│         }
│     }
│ }
│ """
│ 
│ # Create vectors
│ v1 = Vec2DD(3.0, 4.0)
│ v2 = Vec2DD(1.0, 2.0)
│ 
│ # Access fields
│ println("v1: ($(v1.x), $(v1.y))")  # => v1: (3.0, 4.0)
│ 
│ # Modify fields
│ v1.x = 5.0
│ println("v1: ($(v1.x), $(v1.y))")  # => v1: (5.0, 4.0)
│ 
│ # Call methods
│ v3 = v1.add(v2)
│ println("v3: ($(v3.x), $(v3.y))")  # => v3: (6.0, 6.0)
│ 
│ # Static method
│ zero = Vec2DD.zero()
│ println("zero: ($(zero.x), $(zero.y))")  # => zero: (0.0, 0.0)
│ 
│ # Clone
│ v4 = copy(v1)
│ v4.scale(2.0)
│ println("v1 magnitude: $(v1.magnitude())")  # => v1 magnitude: 6.4031242374328485
│ println("v4 magnitude: $(v4.magnitude())")  # => v4 magnitude: 12.806248474865697
│ ```
│   exception =
│    syntax: "LastCall.##args#326" is not a valid function argument name around /Users/terasaki/work/atelierarith/LastCall.jl/src/structs.jl:714
│    Stacktrace:
│      [1] top-level scope
│        @ struct_mapping.md:415
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:194-204
│ ```@example troubleshooting
│ # Dangerous: invalid pointer
│ ptr = Ptr{Cvoid}(0x1000)
│ 
│ # Safe: from valid array
│ arr = [1, 2, 3]
│ ptr = pointer(arr)
│ GC.@preserve arr begin
│     # Use ptr
│ end
│ ```
│   exception =
│    MethodError: no method matching Ptr{Nothing}(::UInt16)
│    The type `Ptr{Nothing}` exists, but no method is defined for this combination of argument types when trying to construct it.
│    
│    Closest candidates are:
│      Ptr{T}(!Matched::Cwstring) where T<:Union{Nothing, Int32}
│       @ Base strings/cstring.jl:34
│      Ptr{T}(!Matched::Cstring) where T<:Union{Nothing, Int8, UInt8}
│       @ Base strings/cstring.jl:33
│      (::Type{Ptr{T}} where T)(!Matched::Union{Int64, UInt64, Ptr})
│       @ Core boot.jl:973
│      ...
│    
│    Stacktrace:
│      [1] top-level scope
│        @ troubleshooting.md:196
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:232-235
│ ```@example troubleshooting
│ # UTF-8 strings are handled automatically
│ @rust process_string("こんにちは")::UInt32
│ ```
│   exception =
│    Function 'process_string' not found in library 'rust_8767e1172777d20f'
│    Stacktrace:
│      [1] error(s::String)
│        @ Base ./error.jl:44
│      [2] get_function_pointer(lib_name::String, func_name::String)
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/ruststr.jl:69
│      [3] _rust_call_typed(::String, ::String, ::Type, ::String, ::Vararg{String})
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/rustmacro.jl:221
│      [4] top-level scope
│        @ troubleshooting.md:234
│      [5] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [6] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [7] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [8] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [9] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│     [10] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│     [11] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│     [12] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [13] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:244-250
│ ```@example troubleshooting
│ # Recommended
│ result = @rust add(10i32, 20i32)::Int32
│ 
│ # Not recommended
│ result = @rust add(10i32, 20i32)
│ ```
│   exception =
│    UndefVarError: `i32` not defined in `Main.__atexample__named__troubleshooting`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ troubleshooting.md:246
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:273-277
│ ```@example troubleshooting
│ # Rust: *const u8
│ # Julia: String (auto-converted)
│ @rust process_string("hello")::UInt32
│ ```
│   exception =
│    Function 'process_string' not found in library 'rust_8767e1172777d20f'
│    Stacktrace:
│      [1] error(s::String)
│        @ Base ./error.jl:44
│      [2] get_function_pointer(lib_name::String, func_name::String)
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/ruststr.jl:69
│      [3] _rust_call_typed(::String, ::String, ::Type, ::String, ::Vararg{String})
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/rustmacro.jl:221
│      [4] top-level scope
│        @ troubleshooting.md:276
│      [5] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [6] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [7] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [8] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [9] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│     [10] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│     [11] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│     [12] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [13] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:286-293
│ ```@example troubleshooting
│ box = RustBox{Int32}(ptr)
│ try
│     # Use box
│ finally
│     drop!(box)  # Always cleanup
│ end
│ ```
│   exception =
│    MethodError: no method matching RustBox{Int32}(::Ptr{Int32})
│    The type `RustBox{Int32}` exists, but no method is defined for this combination of argument types when trying to construct it.
│    
│    Closest candidates are:
│      RustBox{T}(!Matched::Ptr{Nothing}) where T
│       @ LastCall ~/work/atelierarith/LastCall.jl/src/types.jl:304
│    
│    Stacktrace:
│      [1] top-level scope
│        @ troubleshooting.md:287
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:389-405
│ ```@example troubleshooting
│ rust"""
│ // Library 1
│ #[no_mangle]
│ pub extern "C" fn func1() -> i32 { 1 }
│ """
│ 
│ rust"""
│ // Library 2
│ #[no_mangle]
│ pub extern "C" fn func2() -> i32 { 2 }
│ """
│ 
│ # Both usable
│ result1 = @rust func1()::Int32
│ result2 = @rust func2()::Int32
│ ```
│   exception =
│    Function 'func1' not found in library 'rust_3c53fb694a010680'
│    Stacktrace:
│      [1] error(s::String)
│        @ Base ./error.jl:44
│      [2] get_function_pointer(lib_name::String, func_name::String)
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/ruststr.jl:69
│      [3] _rust_call_typed(::String, ::String, ::Type)
│        @ LastCall ~/work/atelierarith/LastCall.jl/src/rustmacro.jl:221
│      [4] top-level scope
│        @ troubleshooting.md:403
│      [5] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [6] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [7] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [8] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [9] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│     [10] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│     [11] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│     [12] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [13] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Error: failed to run `@example` block in docs/src/troubleshooting.md:441-444
│ ```@example troubleshooting
│ result = some_rust_function()
│ value = unwrap_or(result, default_value)
│ ```
│   exception =
│    UndefVarError: `some_rust_function` not defined in `Main.__atexample__named__troubleshooting`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ troubleshooting.md:442
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Debug: Evaluating @example block:
│ clear_cache()
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # List cached libraries
│ list_cached_libraries()
│ 
│ # Check cache size
│ get_cache_size()
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # Check type mapping
│ rusttype_to_julia(:i32)  # => Int32
│ juliatype_to_rust(Int32)  # => "i32"
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Running ExpanderPipeline on tutorial.md
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:55
┌ Debug: Evaluating @setup block:
│ using LastCall
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:1034
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn add(a: i32, b: i32) -> i32 {
│     a + b
│ }
│ """
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # With type inference
│ result = @rust add(Int32(10), Int32(20))::Int32
│ println(result)  # => 30
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn multiply(x: f64, y: f64) -> f64 {
│     x * y
│ }
│ 
│ #[no_mangle]
│ pub extern "C" fn subtract(a: i64, b: i64) -> i64 {
│     a - b
│ }
│ """
│ 
│ # Usage
│ product = @rust multiply(3.0, 4.0)::Float64  # => 12.0
│ difference = @rust subtract(100, 30)::Int64  # => 70
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # Not recommended - relies on inference (works but not recommended)
│ result = @rust add(10i32, 20i32)
│ 
│ # Recommended - explicit type specification
│ result = @rust add(10i32, 20i32)::Int32
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Error: failed to run `@example` block in docs/src/tutorial.md:120-126
│ ```@example tutorial
│ # Not recommended - relies on inference (works but not recommended)
│ result = @rust add(10i32, 20i32)
│ 
│ # Recommended - explicit type specification
│ result = @rust add(10i32, 20i32)::Int32
│ ```
│   exception =
│    UndefVarError: `i32` not defined in `Main.__atexample__named__tutorial`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ tutorial.md:122
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn is_positive(x: i32) -> bool {
│     x > 0
│ }
│ """
│ 
│ @rust is_positive(Int32(5))::Bool   # => true
│ @rust is_positive(Int32(-5))::Bool  # => false
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn string_length(s: *const u8) -> u32 {
│     let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };
│     c_str.to_bytes().len() as u32
│ }
│ """
│ 
│ # Julia String is automatically converted to Cstring
│ len = @rust string_length("hello")::UInt32  # => 5
│ len = @rust string_length("世界")::UInt32   # => 6 (UTF-8 bytes)
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn count_chars(s: *const u8) -> u32 {
│     let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };
│     let utf8_str = std::str::from_utf8(c_str.to_bytes()).unwrap();
│     utf8_str.chars().count() as u32
│ }
│ """
│ 
│ # Count UTF-8 characters
│ count = @rust count_chars("hello")::UInt32    # => 5
│ count = @rust count_chars("世界")::UInt32     # => 2 (characters, not bytes)
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ rust"""
│ #[no_mangle]
│ pub extern "C" fn divide(a: i32, b: i32) -> i32 {
│     if b == 0 {
│         return -1;  // Return -1 as error code
│     }
│     a / b
│ }
│ """
│ 
│ # Error checking
│ result = @rust divide(Int32(10), Int32(2))::Int32
│ if result == -1
│     println("Division by zero!")
│ end
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # Create RustResult manually
│ ok_result = RustResult{Int32, String}(true, Int32(42))
│ is_ok(ok_result)  # => true
│ unwrap(ok_result)  # => 42
│ 
│ err_result = RustResult{Int32, String}(false, "error message")
│ is_err(err_result)  # => true
│ unwrap_or(err_result, Int32(0))  # => 0
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ err_result = RustResult{Int32, String}(false, "division by zero")
│ try
│     value = result_to_exception(err_result)
│ catch e
│     if e isa RustError
│         println("Rust error: $(e.message)")
│     end
│ end
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # Check cache size
│ size = get_cache_size()
│ println("Cache size: $size bytes")
│ 
│ # List cached libraries
│ libs = list_cached_libraries()
│ println("Cached libraries: $libs")
│ 
│ # Cleanup old cache (older than 30 days)
│ cleanup_old_cache(30)
│ 
│ # Clear all cache
│ clear_cache()
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Debug: Evaluating @example block:
│ # Recommended
│ result = @rust add(10i32, 20i32)::Int32
│ 
│ # Not recommended (relies on type inference)
│ result = @rust add(10i32, 20i32)
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Error: failed to run `@example` block in docs/src/tutorial.md:392-398
│ ```@example tutorial
│ # Recommended
│ result = @rust add(10i32, 20i32)::Int32
│ 
│ # Not recommended (relies on type inference)
│ result = @rust add(10i32, 20i32)
│ ```
│   exception =
│    UndefVarError: `i32` not defined in `Main.__atexample__named__tutorial`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ tutorial.md:394
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Debug: Evaluating @example block:
│ # Use Result type
│ result = some_rust_function()
│ if is_err(result)
│     # Handle error
│     return
│ end
│ value = unwrap(result)
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Error: failed to run `@example` block in docs/src/tutorial.md:402-410
│ ```@example tutorial
│ # Use Result type
│ result = some_rust_function()
│ if is_err(result)
│     # Handle error
│     return
│ end
│ value = unwrap(result)
│ ```
│   exception =
│    UndefVarError: `some_rust_function` not defined in `Main.__atexample__named__tutorial`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ tutorial.md:404
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Debug: Evaluating @example block:
│ box = RustBox{Int32}(ptr)
│ try
│     # Use box
│ finally
│     drop!(box)  # Always cleanup
│ end
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
┌ Error: failed to run `@example` block in docs/src/tutorial.md:416-423
│ ```@example tutorial
│ box = RustBox{Int32}(ptr)
│ try
│     # Use box
│ finally
│     drop!(box)  # Always cleanup
│ end
│ ```
│   exception =
│    UndefVarError: `ptr` not defined in `Main.__atexample__named__tutorial`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] top-level scope
│        @ tutorial.md:417
│      [2] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│      [3] #61
│        @ ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:879 [inlined]
│      [4] cd(f::Documenter.var"#61#62"{Module, Expr}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│      [5] (::Documenter.var"#59#60"{Documenter.Page, Module, Expr})()
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:878
│      [6] (::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream})()
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:170
│      [7] with_logstate(f::IOCapture.var"#12#13"{Type{InterruptException}, Documenter.var"#59#60"{Documenter.Page, Module, Expr}, IOContext{Base.PipeEndpoint}, IOContext{Base.PipeEndpoint}, IOStream, IOStream}, logstate::Base.CoreLogging.LogState)
│        @ Base.CoreLogging ./logging/logging.jl:542
│      [8] with_logger(f::Function, logger::Base.CoreLogging.ConsoleLogger)
│        @ Base.CoreLogging ./logging/logging.jl:653
│      [9] capture(f::Documenter.var"#59#60"{Documenter.Page, Module, Expr}; rethrow::Type, color::Bool, passthrough::Bool, capture_buffer::IOBuffer, io_context::Vector{Any})
│        @ IOCapture ~/.julia/packages/IOCapture/MR051/src/IOCapture.jl:167
│     [10] runner(::Type{Documenter.Expanders.ExampleBlocks}, node::MarkdownAST.Node{Nothing}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:877
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:47
┌ Debug: Evaluating @example block:
│ clear_cache()
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/expander_pipeline.jl:860
[ Info: CrossReferences: building cross-references.
┌ Debug: Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
│   exception =
│    UndefVarError: `tutorial` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Tutorial](@ref \"tutorial.md\")" in docs/src/struct_mapping.md.
│ - Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
│   exception =
│    UndefVarError: `examples` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Examples](@ref \"examples.md\")" in docs/src/struct_mapping.md.
│ - Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
│   exception =
│    UndefVarError: `api` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[API Reference](@ref \"api.md\")" in docs/src/struct_mapping.md.
│ - Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `generics.md`: unable to get the binding for `generics.md` in module Main
│   exception =
│    UndefVarError: `generics` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Generics](@ref \"generics.md\")" in docs/src/struct_mapping.md.
│ - Exception trying to find docref for `generics.md`: unable to get the binding for `generics.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
│   exception =
│    UndefVarError: `tutorial` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Tutorial](@ref \"tutorial.md\")" in docs/src/generics.md.
│ - Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
│   exception =
│    UndefVarError: `examples` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Examples](@ref \"examples.md\")" in docs/src/generics.md.
│ - Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `generics.md`: unable to get the binding for `generics.md` in module Main
│   exception =
│    UndefVarError: `generics` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Generics](@ref \"generics.md\")" in docs/src/troubleshooting.md.
│ - Exception trying to find docref for `generics.md`: unable to get the binding for `generics.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
│   exception =
│    UndefVarError: `tutorial` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Tutorial](@ref \"tutorial.md\")" in docs/src/examples.md.
│ - Exception trying to find docref for `tutorial.md`: unable to get the binding for `tutorial.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
│   exception =
│    UndefVarError: `api` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[API Reference](@ref \"api.md\")" in docs/src/examples.md.
│ - Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
│   exception =
│    UndefVarError: `examples` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Examples](@ref \"examples.md\")" in docs/src/tutorial.md.
│ - Exception trying to find docref for `examples.md`: unable to get the binding for `examples.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `troubleshooting.md`: unable to get the binding for `troubleshooting.md` in module Main
│   exception =
│    UndefVarError: `troubleshooting` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[Troubleshooting](@ref \"troubleshooting.md\")" in docs/src/tutorial.md.
│ - Exception trying to find docref for `troubleshooting.md`: unable to get the binding for `troubleshooting.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
│   exception =
│    UndefVarError: `api` not defined in `Main`
│    Suggestion: check for spelling errors or missing imports.
│    Stacktrace:
│      [1] getmod
│        @ ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:70 [inlined]
│      [2] binding(m::Module, x::Expr)
│        @ Documenter.DocSystem ~/.julia/packages/Documenter/xvqbW/src/DocSystem.jl:62
│      [3] find_docref(code::SubString{String}, mod::Module, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:453
│      [4] docsxref(node::MarkdownAST.Node{Nothing}, code::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:399
│      [5] runner(::Type{Documenter.XRefResolvers.Docs}, node::MarkdownAST.Node{Nothing}, slug::SubString{String}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document, errors::Vector{String})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:261
│      [6] dispatch(::Type{Documenter.XRefResolvers.XRefResolverPipeline}, ::MarkdownAST.Node{Nothing}, ::Vararg{Any})
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│      [7] xref(node::MarkdownAST.Node{Nothing}, meta::Dict{Symbol, Any}, page::Documenter.Page, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:311
│      [8] crossref(doc::Documenter.Document, page::Documenter.Page, mdast::MarkdownAST.Node{Nothing})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:49
│      [9] crossref(doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:17
│     [10] runner(::Type{Documenter.Builder.CrossReferences}, doc::Documenter.Document)
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:231
│     [11] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
│        @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
│     [12] #89
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
│     [13] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
│        @ Base ./env.jl:265
│     [14] #87
│        @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
│     [15] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
│        @ Base.Filesystem ./file.jl:112
│     [16] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
│        @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
│     [17] top-level scope
│        @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
│     [18] include(mapexpr::Function, mod::Module, _path::String)
│        @ Base ./Base.jl:307
│     [19] top-level scope
│        @ none:1
│     [20] eval(m::Module, e::Any)
│        @ Core ./boot.jl:489
│     [21] exec_options(opts::Base.JLOptions)
│        @ Base ./client.jl:283
│     [22] _start()
│        @ Base ./client.jl:550
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/cross_references.jl:403
┌ Warning: Cannot resolve @ref for md"[API Reference](@ref \"api.md\")" in docs/src/tutorial.md.
│ - Exception trying to find docref for `api.md`: unable to get the binding for `api.md` in module Main
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
[ Info: CheckDocument: running document checks.
┌ Debug: checking for missing docstrings.
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/docchecks.jl:42
┌ Warning: 8 docstrings not included in the manual:
│ 
│     LastCall.IRUST_FUNCTIONS
│     LastCall.CURRENT_LIB
│     LastCall.FUNCTION_REGISTRY
│     LastCall.RUST_LIBRARIES
│     LastCall.RUST_TO_JULIA_TYPE_MAP
│     LastCall.JULIA_TO_RUST_TYPE_MAP
│     LastCall.RUST_MODULE_REGISTRY
│     LastCall.MODULE_ACTIVE_LIB
│ 
│ These are docstrings in the checked modules (configured with the modules keyword)
│ that are not included in canonical @docs or @autodocs blocks.
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/utilities/utilities.jl:49
┌ Debug: checking footnote links.
└ @ Documenter ~/.julia/packages/Documenter/xvqbW/src/docchecks.jl:123
[ Info: Populate: populating indices.
ERROR: LoadError: `makedocs` encountered an error [:example_block] -- terminating build before rendering.
Stacktrace:
  [1] error(s::String)
    @ Base ./error.jl:44
  [2] runner(::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Document)
    @ Documenter ~/.julia/packages/Documenter/xvqbW/src/builder_pipeline.jl:259
  [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Document)
    @ Documenter.Selectors ~/.julia/packages/Documenter/xvqbW/src/utilities/Selectors.jl:170
  [4] #89
    @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:283 [inlined]
  [5] withenv(::Documenter.var"#89#90"{Documenter.Document}, ::Pair{String, Nothing}, ::Vararg{Pair{String, Nothing}})
    @ Base ./env.jl:265
  [6] #87
    @ ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:282 [inlined]
  [7] cd(f::Documenter.var"#87#88"{Documenter.Document}, dir::String)
    @ Base.Filesystem ./file.jl:112
  [8] makedocs(; debug::Bool, format::Documenter.HTMLWriter.HTML, kwargs::@Kwargs{sitename::String, modules::Vector{Module}, authors::String, warnonly::Vector{Symbol}, pages::Vector{Pair{String, Any}}})
    @ Documenter ~/.julia/packages/Documenter/xvqbW/src/makedocs.jl:281
  [9] top-level scope
    @ ~/work/atelierarith/LastCall.jl/docs/make.jl:4
 [10] include(mapexpr::Function, mod::Module, _path::String)
    @ Base ./Base.jl:307
 [11] top-level scope
    @ none:1
 [12] eval(m::Module, e::Any)
    @ Core ./boot.jl:489
 [13] exec_options(opts::Base.JLOptions)
    @ Base ./client.jl:283
 [14] _start()
    @ Base ./client.jl:550
in expression starting at /Users/terasaki/work/atelierarith/LastCall.jl/docs/make.jl:4
